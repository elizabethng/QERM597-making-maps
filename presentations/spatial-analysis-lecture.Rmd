---
title: "Spatial Analysis in R"
subtitle: "QERM 597 Winter 2020"
author: "Elizabeth Ng, Brielle Kwarta, Michele Buonanduci, and Harry Podschwit "
date: " `r Sys.Date()`"
output:
  ioslides_presentation:
    smaller: true
  powerpoint_presentation: default
  html_document: default
  slidy_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, collapse = TRUE)

library("rnaturalearth")
library("tidyverse")
library("sf")
library("here")
library("htmltab")
library("lwgeom")
library("rnaturalearthdata")
library("rgeos")
library("ggmap")
# scrape html data
```


## Learning Objectives
1. Plot vector geospatial data (points/polygons)
2. Plot raster geospatial data (image)
3. Extracting data from raster
4. Making maps (Compass rose, overlays, etc)


<!-- ## Overview -->
<!-- 1. Motivation -->
<!-- 2. Brief intro to generic spatial data -->
<!-- 3. Brief intro to spatial capabilities in R -->
<!-- 4. Intro to the sf package -->
<!-- 5. Reading and writing spatial data with `sf` -->
<!-- 6. Geometric operations with `sf` -->
<!-- 7. Making maps with `sf` and `ggplot2` -->



```{r echo = FALSE, fig.align="center"}
knitr::include_graphics(here("imgs", "arc-to-R-workflow.gif"))
```


<!-- ####################################################################### -->
<!-- ## Why spatial data? -->
<!-- ##* Interesting spatial questions -->
<!-- ##* Earth is round-ish/spherioid -->
<!-- ##* Maps and screens are flat, so we only see projected data -->
<!-- ##* Projected distances, areas, shapes, and directions are distorted -->
<!-- ## -->
<!-- ####################################################################### -->
<!-- ##HP: I proposed starting with the research question directly. It makes it  -->
<!-- ##obvious why we need spatial data because we have a well defined question  -->
<!-- ##that necessitates it -->

## Motivation
We are researchers who want to answer the question "What range of environmental conditions do *taxon* tend to inhabit?"

General workflow:

 - Plot locations of *taxon*
 - Plot map of environmental conditions
 - Plot contextual information 
 - Extract data about environmental conditions at those locations
 
* Variants of this question/workflow are applicable to others study systems.



<!-- ## Reference systems -->
<!-- ##* [Geodesic/geographic coordinates](https://edzer.github.io/rstudio_conf/#6) need -->
<!-- ##  - Order (lat/long vs long/lat) -->
<!-- ##  - Units (rad, arc_degree) -->
<!-- ##  - Datum (aka reference ellipsoid) -->
<!-- ##    <!-- * how are we describing the shape of the Earth? --> -->
<!-- ##    <!-- * "best" approximation depends on region and scale --> -->
<!-- ##    <!--   - what origin is used? --> -->
<!-- ##    <!--   - tectonic plates move over time --> -->
<!-- ##    <!--   - e.g., WGS84, is an approximate model of Earth at sea level updated in 2004 --> -->
<!-- ##* [Cartesian/projected coordinates](https://www.axismaps.com/guide/general/map-projections/) need -->
<!-- ##  - Units (km, m) -->
<!-- ##  - Relationship to a datum/geodesic coordinates -->
<!-- ##  - How to display 3D object in 2D -->
<!-- ##  - Accurately display one of: area (Mercator), form (Azimuthal Equidistant), distance (Equirectangular) -->
<!-- ##  <!-- - choice depends on what you're conveying, shape of the region --> -->
<!-- ##  <!-- - e.g., use Tranverse Mercator for mapping long N-S region like Chile --> -->
<!-- ##* Two separate issues: how do we model Earth (datum) and how do we display it on a flat surface (projection) -->


<!-- ##<!-- ## Models of a round-ish Earth --> -->
<!-- ##<!-- * There are different models of the Earth --> -->
<!-- ##<!-- * Meaning of coordinates (lon/lat) depend on the geodetic datum --> -->
<!-- ##<!-- * "_Geodetic datum_ is a coordinate reference system and a set of reference points used to locate places on Earth"[Wikipedia](https://en.m.wikipedia.org/wiki/Geodetic_datum) --> -->
<!-- ##<!-- * "a datum is unlikely important when mapping continents, but it is when when drones try to deliver pizza" -[Edzer ##Pebesma]https://edzer.github.io/rstudio_conf/#6) --> -->
<!-- ##<!-- * Depend on the scale (big or small matter more? where you are matters?) --> -->
<!-- ##<!-- * On one hand, small areas are more easily modeled as a flat surface --> -->
<!-- ##<!-- * But get your model wrong from continent to drone delivery matters --> -->
<!-- ##<!-- * Model is described in a coordinate reference system (CRS) --> -->
<!-- ##<!-- * Two types --> -->
<!-- ##<!--   - geographic CRS (lon/lat) gives distance from the origin in degrees --> -->
<!-- ##<!--   - projected CRS (easting/northing) gives distance from the origin in km --> -->
<!-- ##<!-- - [ ] Datum?? --> -->
<!-- ################################################################################################################## -->
<!-- ##HP: In the interest of time, I propose that we limit our discussion of projections. All we really need to mention is that  -->
<!-- ## there are a variety of geospatial models of the earth, and that it is critical that all your data are assuming the same model.  -->


## Representation of spatial data
- *Vector data model* uses points, lines, and polygons (e.g. locations of animals, ecosystem types)
- *Raster data model* divides surface into cells of constant size (e.g. gridded temperature)
- Non spatial attribute data
  - How many counts at a point?
  - Length of a transect
  - Land-cover type of a polygon

## To answer our research question, we will need to:
1. Read/write spatial data
2. Represent geographic and attribute data
3. Transform between different models of Earth
4. Geographic operations
5. Make maps


# Spatial analysis in R

## R packages for spatial analysis
- [Many tools for spatial analysis in R](https://cran.r-project.org/web/views/Spatial.html)
- `rgdal` released in 2003--import from more geographic data formats
- `sp` released in 2005--creates spatial objects with classes and generic methods for points, lines, polygons, grids, and attribute data (but still lacked ability to do geometric operations)
- `raster` released in 2010--support for raster operations and more

## R packages linking to GIS software
- `GRASS`, `spgrass6`, and `rgrass7`
- `RSAGA`, `RPyGeo`, and `RQGIS`

## Visualization
- `ggplot2`
- `ggmap`
- `rasterVis`
- `tmap`
- `leaflet`
- `mapview`
<!-- ####################################################### -->
<!-- ##HP: Leave as is, but we should just say something like "there are many methods available in R for performing geospatial analysis, here  -->
<!-- ## is a sample of some of the choices that you can also explore, but we limit ourseleves in scope to packages A,B,C,.... -->


<!-- QUESTION FOR ALL### -->
<!-- Which packages will we be exploring? Make sure my list is accurate.  -->
<!-- 1. "sf" -->
<!-- 2. "raster" -->
<!-- 3. "naturalearth" -->
<!-- 4. "ggmap" -->


## My choice: `sf`
* Developed in 2016 with support from [R consortium](https://github.com/r-spatial/sf/blob/master/PROPOSAL.md)
* Based on [simple features ISO standards](https://en.wikipedia.org/wiki/Simple_Features) that are not R specific
* Replaces `sp`, `rdgal` for read/write, and `rgeos` for geometric operations
* Integrates well with `tidyverse`

## Resources
* [Simple Features package](https://r-spatial.github.io/sf/index.html)
  - Vignettes, blogs, presentations
  - [Cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/sf.pdf)
  - [issue tracker](https://github.com/r-spatial/sf/issues/)
* [r-spatial](https://www.r-spatial.org/about/) Edzer Pebesma's blog
* [Spatial Data Science](https://keen-swartz-3146c4.netlify.com/)
* [Geocomputation with R](https://geocompr.robinlovelace.net/)
  - excellent in-depth treatment
  - includes theory, examples, and covers rasters


# PART I: PLOTTING POINT AND SHAPEFILE DATA
# DATA: 1. *taxon* point locations, 2. relevant shapefile (Ecosystem type?, country?)

# `sf` package

## Simple features
* _feature_ "abstraction of real world phenomena"
* _simple feature_ "feature with all geometric attributes described by piecewise straight lines or planar interpolation between sets of points"
* Represents geometry using *points*, *lines*, *polygons*, or collections of those features
* ISO standard supported by lots of software

## Basic structure
* `sf` (simple feature) objects are extended `data.frame`s or `tibble`s
  - attribute data stored as `tibble`
  - geometry stored as a list column
  - can have multiple types of geometry in one object
* class is `sfc` (simple feature columns) with bounding box `bbox` and `CRS` (coordinate reference system) attributes



---
```{r}
fileloc <- system.file("shape/nc.shp", package = "sf")
nc <- read_sf(fileloc) %>%
  select(AREA, NAME)
print(nc)
# Highlight parts
# 1. list column (aka sfc)
# 2. feature geometry (sfg)
# 3. feature (row)
```

## `sf` and `tidyverse`
* `sf` functions begin with `st_`
* Methods for `summary`, `plot`
* `sf` methods for `filter`, `arrange`, `distinct`, `group_by`, `ungroup`, `mutate`
```{r echo = TRUE}
methods(class = "sf")
```


---
```{r echo = TRUE}
st_geometry(nc) %>% plot 
```

---
```{r echo = TRUE}
# Default methods for objects
plot(nc)

plot(nc[,3])
```

---
```{r echo = TRUE}
filter(nc, AREA > 0.2)
```

# Reading and writing data

## Reading shapefiles

```{r echo = TRUE}
fileloc <- system.file("shape/nc.shp", package = "sf")
nc <- read_sf(fileloc)
```

* st_crs() used to convert coordinates (do projections) and do datum transformations
* Proj.4 string or ESPG code contains this info
* [Web](https://spatialreference.org/) [repositories](https://georepository.com/home.html) for ESPG and Proj.4 information

---
```{r echo = TRUE}
st_crs("+proj=longlat +datum=WGS84") # Proj.4 string"
st_crs(3857)                         # ESPG code: public registry of spatial reference systems, 3857 = web-based mapping (i.e. Google                                         maps, OpenStreetMap)
st_crs(3857)$units                   # check units
st_crs(NA)                           # unknown (assumed planar/Cartesian)
```

---
* `st_transform` transforms or converts coordinates to [new reference system](https://edzer.github.io/UseR2017/)
```{r echo = TRUE}
(a1 <- st_area(nc[1,])) # area, using geosphere::areaPolygon
(a2 <- st_area(st_transform(nc[1, ], 32119))) # NC state plane, m
(a3 <- st_area(st_transform(nc[1,], 2264)))   # NC state plane, US foot
```

---
```{r echo = TRUE}
units::set_units(a1, km^2)
units::set_units(a2, km^2)
units::set_units(a3, km^2)
```


## Other data sources
> * Convert from other `Spatial*` objects using `st_as_sf`
> * Convert long/lat data
> * Packages such as `rnaturalearth`

## Convert long/lat data
```{r warning = FALSE}
# Scrape some lat/lon data (see example at https://ryanpeek.github.io/2017-08-03-converting-XY-data-with-sf-package/)
url <- "http://www.hotspringsdirectory.com/usa/ca/gps-usa-ca.html"
df <- htmltab(url, which = 1, header = 1,
              colNames = c("STATE","LAT","LONG","SpringName","Temp_F", "Temp_C", "AREA", "USGS_quad"))
hotsprings_df <- df %>%
  as_tibble() %>%
  mutate(LAT = as.numeric(LAT),
         LONG = as.numeric(LONG),
         Temp_F = as.numeric(Temp_F),
         Temp_C = as.numeric(Temp_C),
         LONG = -LONG) %>%
  na.omit()
```

```{r, echo = TRUE}
head(hotsprings_df)
```

## Convert long/lat data
* Assume that these data are WGS84 (`crs = 4326`)
* WGS84: World Geodic System 1984
* 4326=coordinate system based on Earth's center of mass
```{r, echo = TRUE}
hotsprings <- st_as_sf(hotsprings_df,
                       coords = c("LONG", "LAT"),
                       crs = 4326)
head(hotsprings)
```


## Data from packages
```{r, echo = TRUE}
world <- ne_countries(scale = "medium", returnclass = "sf")
st_geometry(world) %>% plot()
```

## Writing data
* shapefiles
* database connections
* use `st_write`

## Exercises
1. Load the roads shapefile (enproads.shp) and upload `Zebra.csv` and plot the geometry. 
2. If we look at our roads data, we see that there are several types of roads in the shapefile. How close or far from different road types do zebra move? 

## Exercise 1
```{r, echo = TRUE}
roads <- st_read(here("data", "enproads.shp"), crs = "+init=epsg:4326") %>% #4326= coordinate system based on Earth's center of mass
  st_transform("+init=epsg:32733") #32733 = spatial reference for Nambia 

st_geometry(roads) %>% plot


zebra_sf <- read.csv(here("data", "Zebra.csv")) %>% 
  dplyr::select(ID = Name, 4:6) %>% 
  mutate(timestamp = as.POSIXct(lubridate::mdy_hm(Date))) %>%
  st_as_sf(., coords = 3:4, crs = "+init=epsg:4326") %>% #longlat, converting foreign object to SF object
  st_transform("+init=epsg:32733") #convert to UTM

ggplot() +
  geom_sf(data=roads) +
  geom_sf(data=zebra_sf, aes(color=ID))

```

## Exercise 2
How close or far from different road types do zebra move? 
```{r, echo = TRUE}
unique(roads$TYPE)

#Filter roads based off type:
large_roads <- filter(roads, TYPE %in% c("Tar", "Gravel"))
small_roads <- filter(roads, TYPE %in% c("Graded", "Track"))

ggplot() +
  geom_sf(data=large_roads, size=1.5) + 
  geom_sf(data=small_roads, size=0.6) + 
  geom_sf(data=zebra_sf, aes(color=ID))


# Find the minimum distance (in meters) of each point to a large road
large_dist<- st_distance(y=zebra_sf, x=large_roads) # a units matrix dim =[nrow(x), nrow(y)]; takes 10-20 seconds
zebra_sf$large_road_dist <- apply(large_dist, 2, min)

# Find the minimum distance (in meters) of each point to a small road
small_dist<- st_distance(y=zebra_sf, x=small_roads) # a units matrix dim =[nrow(x), nrow(y)]; takes 10-20 seconds
zebra_sf$small_road_dist <- apply(small_dist, 2, min)

head(data.frame(zebra_sf))

ggplot(zebra_sf) +
  geom_histogram(aes(large_road_dist, fill="large roads"), alpha=0.5) +
  geom_histogram(aes(small_road_dist, fill="small roads"), alpha=0.5) +
  scale_fill_manual(labels=c("large roads", "small roads"), values=c("blue", "orange"))

```

# PART II: PLOTTING RASTER DATA AND EXTRACTING INFORMATION
# DATA: 1. *taxon* point locations, 2. relevant shapefile (Ecosystem type?, country?)

#Step 1: Get raster (.tiff) file into workspace
NDVI_mean <- raster("ndvi_mean_utm.tif") * 0.0001
NDVI_mean

#Step 2: Plot raster and zebra location data
NDVI_mean %>% 
  rasterToPoints() %>%
  data.frame() %>%
  ggplot() + geom_raster(aes(x=x, y=y, fill=ndvi_mean_utm)) +
  geom_sf(data=zebra_sf, size=0.7,col="black")

#Step 3: Extract NDVI a locations
zebra_sf$NDVI_mean <- raster::extract(NDVI_mean, as(zebra_sf, "Spatial"))

head(data.frame(zebra_sf))

#Step 4: Plot locations colored by NDVI
ggplot(zebra_sf) +
  geom_sf(aes(color=NDVI_mean)) + 
  scale_color_gradientn(colors=rev(terrain.colors(10))) +
  theme_bw()


#####ADD MULTIDIMENSIONAL ANALYSIS
#####EXERCISE 1
#####EXERCISE 2


# PART III: MAKING NICE MAPS

## Basics
- Making maps with `sf` and `ggplot2`
- interfaces with `ggplot2` using `geom_sf`

## Adding basemaps!
- Focus on `ggmap`
- As of mid-2018, requires registering with Google and obtaining an API key
- Requires providing a valid credit card (yikes!), though charges are nonexistent or at least very minimal
- See the `ggmap` [GitHub page](https://github.com/dkahle/ggmap) for more information about API keys

## Basemap options from `ggmap`
- Basemaps available from Google, Stamen, or Open Street Map
- Terrain, satellite, or watercolor
- See this helpful [cheat sheet](https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/ggmap/ggmapCheatsheet.pdf)

## Making maps using `ggmap`
Two steps:

- Download basemap raster
- Plot raster and overlay other spatial data

## Register API key at start of session

This is my personal API key, which you can use for the purposes of this class!

```{r API key, echo=TRUE}
register_google(key = "AIzaSyBRkw_wzDKuWZDikdD86Kmp1Sa6PzuCKFc")
```

## Stamen basemaps

To add a Stamen basemap, first define the bounding box for the basemap you would like to download.

```{r Stamen bbox, echo=TRUE}
zebra_bbox <- c(14, -20, 17.5, -18)
names(zebra_bbox) <- c("left", "bottom", "right", "top")
```

## Stamen basemaps: terrain
```{r Stamen terrain, echo=TRUE, warning=FALSE, message=FALSE, fig.height=3.5}
terr_basemap <- get_stamenmap(bbox=zebra_bbox, zoom=9, maptype="terrain")

ggmap(terr_basemap) +
  geom_sf(data=large_roads, size=1.5, inherit.aes = FALSE) + 
  geom_sf(data=small_roads, size=0.6, inherit.aes = FALSE) + 
  geom_sf(data=zebra_sf, aes(color=ID), inherit.aes = FALSE) +
  coord_sf(crs = st_crs(4326))
```

## Stamen basemaps: watercolor
```{r Stamen watercolor, echo=TRUE, warning=FALSE, message=FALSE, fig.height=3.5}
wat_basemap <- get_stamenmap(bbox=zebra_bbox, zoom=9, maptype="watercolor")

ggmap(wat_basemap) +
  geom_sf(data=large_roads, size=1.5, inherit.aes = FALSE) + 
  geom_sf(data=small_roads, size=0.6, inherit.aes = FALSE) + 
  geom_sf(data=zebra_sf, aes(color=ID), inherit.aes = FALSE) +
  coord_sf(crs = st_crs(4326))
```

## Google basemaps

To add a Google basemap, first define the center coordinates for the basemap you would like to download.

```{r Google center, echo=TRUE}
zebra_center <- c(15.8, -19)
names(zebra_center) <- c("lon", "lat")
```

## Google basemaps: satellite
```{r Google satellite, echo=TRUE, warning=FALSE, message=FALSE, fig.height=3.5}
sat_basemap <- get_googlemap(center=zebra_center, zoom=8, size=c(640, 640), scale=2,
                             maptype="satellite")
ggmap(sat_basemap) +
  geom_sf(data=large_roads, size=1.5, inherit.aes = FALSE) + 
  geom_sf(data=small_roads, size=0.6, inherit.aes = FALSE) + 
  geom_sf(data=zebra_sf, aes(color=ID), inherit.aes = FALSE) +
  coord_sf(crs = st_crs(4326))
```

## Google basemaps: satellite

Notice that `get_googlemap()` returns a square basemap tile, which then sets the plotting limits of your map.

To manually set different plotting limits, pass in an empty "base layer" and set x and y limits using `ggplot()`.

## Google basemaps: satellite
```{r Google sat manual limits, echo=TRUE, warning=FALSE, message=FALSE, fig.height=3.5}
ggmap(sat_basemap, maprange=FALSE, base_layer=ggplot(aes(x=1, y=1), data=NULL)) +
  xlim(14.3, 17.4) + ylim(-20, -18) + xlab("lon") + ylab("lat") +
  geom_sf(data=large_roads, size=1.5, inherit.aes = FALSE) + 
  geom_sf(data=small_roads, size=0.6, inherit.aes = FALSE) + 
  geom_sf(data=zebra_sf, aes(color=ID), inherit.aes = FALSE) +
  coord_sf(crs = st_crs(4326))
```

## Adding basemaps: alternative approaches
- An alternative package is `RgoogleMaps`
- No need to get Google API key (yay!)
- Does not seems to be compatible with `ggplot2` (boo)
